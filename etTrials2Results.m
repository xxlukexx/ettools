function res = etTrials2Results(trials, crit_propVal, crit_dataDuration,...
    crit_numTrials)

% default criteria

    if ~exist('crit_propVal', 'var') || isempty(crit_propVal)
        % at least 25% valid samples
        crit_propVal = .25;
    end
    if ~exist('crit_dataDuration', 'var') || isempty(crit_dataDuration)
        % at least 5s of data per trial
        crit_dataDuration = 5;
    end    
    if ~exist('crit_numTrials', 'var') || isempty(crit_numTrials)
        % at least 3 valid trials per subject
        crit_numTrials = 4;
    end    
    
% apply criteria to individual trials

    trials.val_propVal = trials.propVal >= crit_propVal;
    trials.val_dataDuration = trials.dataDuration >= crit_dataDuration;
    trials.valid = trials.val_propVal & trials.val_dataDuration;
    
% form subject * wave * stimulus subscripts

    % convert batteries (e.g. 5MCBCD) to number (e.g. 5)
    waveNum = cell2mat(extractNumeric(trials.wave));
    if size(waveNum, 1) == size(trials, 1)
        trials.wavenum = waveNum;
    else
        trials.wavenum = trials.wave;
    end
    
% count first look to face
    
    % create a new variable with is 1 when the first look is to the face,
    % and 0 when it is not. This will then get aggregated in the next step
    trials.firstLookToFace_prop = strcmpi(trials.firstLook, 'face');
    
% collapse table across subs

    % define aggregation scheme. First col is var names, second column is
    % aggregating function. e.g. propVal returns the mean across all
    % trials, whereas dataDuration is summed
    agg = {...
        'propVal'           ,@nanmean                       ;...   
        'val_propVal'       ,@sum                           ;...
        'dataDuration'      ,@nansum                        ;...
        'val_dataDuration'  ,@sum                           ;...
        'valid'             ,@sum                           ;...
        'firstLookToFace_prop',@(x) sum(x) / length(x)      ;...
        'face_triggered'    ,@nansum                        ;...   
        'face_samplesInAOI' ,@nanmean                       ;...   
        'face_propInAOI'    ,@nanmean                       ;...   
        'face_timeInAOI'    ,@nanmean                       ;...   
        'face_firstSamp'    ,@nanmean                       ;...   
        'face_firstTimeS'   ,@nanmean                       ;...   
        'face_numLooks'     ,@nanmean                       ;...   
        'face_meanLook'     ,@nanmean                       ;...   
        'face_peakLook'     ,@nanmean                       ;...   
        'face_minLook'      ,@nanmean                       ;...   
        'face_ratioInAOI'   ,@nanmean                       ;...   
        'car_triggered'     ,@nansum                        ;...
        'car_samplesInAOI'  ,@nanmean                       ;...   
        'car_propInAOI'     ,@nanmean                       ;...   
        'car_timeInAOI'     ,@nanmean                       ;...   
        'car_firstSamp'     ,@nanmean                       ;...   
        'car_firstTimeS'    ,@nanmean                       ;...   
        'car_numLooks'      ,@nanmean                       ;...   
        'car_meanLook'      ,@nanmean                       ;...   
        'car_peakLook'      ,@nanmean                       ;...   
        'car_minLook'       ,@nanmean                       ;...   
        'car_ratioInAOI'    ,@nanmean                       ;...   
        'phone_triggered'   ,@nansum                        ;...
        'phone_samplesInAOI',@nanmean                       ;...   
        'phone_propInAOI'   ,@nanmean                       ;...   
        'phone_timeInAOI'   ,@nanmean                       ;...   
        'phone_firstSamp'   ,@nanmean                       ;...   
        'phone_firstTimeS'  ,@nanmean                       ;...   
        'phone_numLooks'    ,@nanmean                       ;...   
        'phone_meanLook'    ,@nanmean                       ;...   
        'phone_peakLook'    ,@nanmean                       ;...   
        'phone_minLook'     ,@nanmean                       ;...   
        'phone_ratioInAOI'  ,@nanmean                       ;...   
        'noise_triggered'   ,@nansum                        ;...
        'noise_samplesInAOI',@nanmean                       ;...   
        'noise_propInAOI'   ,@nanmean                       ;...   
        'noise_timeInAOI'   ,@nanmean                       ;...   
        'noise_firstSamp'   ,@nanmean                       ;...   
        'noise_firstTimeS'  ,@nanmean                       ;...   
        'noise_numLooks'    ,@nanmean                       ;...   
        'noise_meanLook'    ,@nanmean                       ;...   
        'noise_peakLook'    ,@nanmean                       ;...   
        'noise_minLook'     ,@nanmean                       ;...   
        'noise_ratioInAOI'  ,@nanmean                       ;...   
        'bird_triggered'    ,@nansum                        ;...
        'bird_samplesInAOI' ,@nanmean                       ;...   
        'bird_propInAOI'    ,@nanmean                       ;...   
        'bird_timeInAOI'    ,@nanmean                       ;...   
        'bird_firstSamp'    ,@nanmean                       ;...   
        'bird_firstTimeS'   ,@nanmean                       ;...   
        'bird_numLooks'     ,@nanmean                       ;...   
        'bird_meanLook'     ,@nanmean                       ;...   
        'bird_peakLook'     ,@nanmean                       ;...   
        'bird_minLook'      ,@nanmean                       ;...   
        'bird_ratioInAOI'   ,@nanmean                       ;...   
        };
    
    % some variables contain inf, for example if an AOI is not triggered,
    % its entry time (to ensure that comparisons such as min(entry time)
    % return sensible results). Aggregating a vector containing inf with
    % @mean will return inf. We essentially want to remove these values
    % before aggregation, so we convert them to nan.
    m = table2array(trials(:, agg(:, 1)));
    setToNan = false(size(m));
    setToNan(m == inf) = true;
    
    % set all rows of invalid trials to NaN, so that they aren't included
    % in the aggergate
    colIsLogical = cellfun(@(x) islogical(trials.(x)),...
        agg(:, 1));
    setToNan(~trials.valid, :) = true;
    setToNan(:, colIsLogical) = false;
    m(setToNan) = nan;
    
    % put data back into trials table
    trials{:, agg(:, 1)} = m;
    
    res = aggregateTable(trials, {'id', 'wavenum'}, agg(:, 1), agg(:, 2));
        
    % rename some aggregated variables so they are not misleading
    res.Properties.VariableNames{'propVal'} = 'propVal_mean';
    res.Properties.VariableNames{'dataDuration'} = 'dataDuration_total';
    res.Properties.VariableNames{'face_triggered'} = 'face_triggered_numTrials';
    res.Properties.VariableNames{'noise_triggered'} = 'noise_triggered_numTrials';
    res.Properties.VariableNames{'bird_triggered'} = 'bird_triggered_numTrials';
    res.Properties.VariableNames{'phone_triggered'} = 'phone_triggered_numTrials';
    res.Properties.VariableNames{'car_triggered'} = 'car_triggered_numTrials';
    res.Properties.VariableNames{'val_propVal'} = 'numVal_propVal';
    res.Properties.VariableNames{'val_dataDuration'} = 'numVal_dataDuration';
    res.Properties.VariableNames{'valid'} = 'valid_numTrials';
    
    % mark valid trials
    res.include = res.valid_numTrials >= crit_numTrials;
    res = movevars(res, 'include', 'after', 'valid_numTrials');
    
    % remove variables that no longer make sense once aggregated
    res.firstLook = [];
    res.stimulus = [];
    
end

